# How to use these methods to compute BWY and BB invariants numerically (requires snappy and flipper)

sage: from BBBLWY import *

# First setup the surface and the mapping class

# Method 1: construct from snappy manifolds
# The drawback is that there is no control over the fiber surface

sage: M = snappy.Manifold("s937")
sage: f = flipper.monodromy_from_bundle(M)
sage: S = f.source_triangulation; (S.genus, S.num_unfilled_vertices)
# output = (1, 3)

# Method 2: construct from predefined Dehn twists and half twists
# the drawback is that flipper doesn't explain which letters are which twists

sage: S = flipper.load("S_1_2")
sage: f = normalize_mapping_class(S.mapping_class("bbbaC"))
sage: assert f.is_pseudo_anosov() and snappy.Manifold(f.bundle()).is_isometric_to(snappy.Manifold("s937"))

# Method 3: specify the surface and mapping class directly

sage: S0 = triangulation_from_tuples([[0,1,4],[1,2,5],[2,3,4],[3,0,5]])
sage: f = S0.encode(to_python([{4:~4r},4,1,0,4,5,2,3,2,5]))

# The mapping class must be a sequence of flips and one closing isometry.
# All flip labels must be nonnegative

# triangulation_from_tuples is a convenience wrapper for flipper.create_triangulation
# to_python is a helper function since flipper does not work well with sage integers
# r is the sage suffix for python int, without it ~4 == 1/4

sage: assert f.is_pseudo_anosov() and snappy.Manifold(f.bundle()).is_isometric_to(snappy.Manifold("s937"))



# If BB is the goal, add decoration to the mapping class
# Otherwise, skip the next and use f

sage: g = dot_enhance(f)

# Then setup the mapping torus. By default, shapes are calculated by snappy.Manifold, which has 10-ish digits typically

# If higher precision is required, use keyword arguments to specify snappy.ManifoldHP, which has 60-ish digits,

# and/or use find_field to attempt to find even higher precision

sage: m = MappingTorus(g, snappy_variant=snappy.ManifoldHP, find_field_args=(60, 4), prec=256)

# To compute the intertwiners, use ACF or AK
# It is optional to compute the representations separately

sage: ACF(m, 1/3).trace().abs()

# output = 6.924363151561973405857882276523615157900270583232230424449589015818702238917

sage: AK(m, 1/3).trace().abs()

# output = 20.77308945468592021757364682957084547370081174969669127334876704745610671675

# The gl1 invariants directly takes the mapping class
# note the determinant is not normalized to 1 here

sage: S = flipper.load("S_1_2")
sage: f = normalize_mapping_class(S.mapping_class("Bacx"))
sage: AH(f, 1/3)
# [    1     0     0]
# [    0     0 zeta3]
# [    0 zeta3     0]


# More advanced features can be imported from submodules

sage: from BBBLWY.surface import CF_decomposition
sage: rho = make_bundle_local_rep(m, 1/3)
sage: A = AK(m, 1/3, rho=rho)
sage: L = CF_decomposition(g.source_triangulation)
sage: Xp = rho[0](L[-2])
sage: (A * Xp.matrix - Xp.matrix * A).norm(1)           # output = 3.181757797865565e-75
sage: D, P = Xp.matrix.diagonalization()
sage: Ap = ~P * A * P
sage: A_blocks = [Ap[27*i:27*(i+1), 27*i:27*(i+1)] for i in range(3)]
sage: vector(B.det() - 1. for B in A_blocks).norm(1)    # output = 6.96978114682077e-59
sage: [B.trace().abs().n() for B in A_blocks]

# output = [1.23856431138585e-76, 20.7730894546859, 6.91916753875734e-77]
